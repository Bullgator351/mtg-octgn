The MTG Autoscript system utilizes "tags" found inside set files. These allow the MTG game definition to automate common actions and interact with the Stack.

These tags are stored as a python dictionary inside the game definition under /scripts/tags.py.
The autoscript system is designed to search for a card's tags by its NAME, so all printings of a card will be affected by a single tag.

Tags take the typical form:
	'CLASS.ACTION[PARAMETERS]; '

Here is an example of what a typical tag looks like:
	'resolve.marker[plusoneplusone, 1]; '

Below is a description of the different types of classes and actions supported (or supported in the future) in the MTG game definition:

##################################################
#classes
##################################################

cast.
  - use when a card requires scripting when it enters the stack (such as from your hand) due to it being CAST.
  - "when/as you cast CARDNAME" effects
  - When a Land enters the battlefield with an ability or modifier that doesn't use the stack (adding counters, enters play tapped, etc.)
  - cards that have X in their mana costs (to add the X marker to the spell on the stack)
  - Additional/Extra costs to cast a card (X in the mana cost, kicker, conspire, traps, etc)

resolve.
  - use when the card has an effect when it resolves from the stack.
  - All instants and sorceries with scriptable effects use this tag
  - Non-land permanents that enter the battlefield with an ability or modification that doesn't use the stack (adding counters, enters play tapped, etc.)
  - NOTE:  If the card has an enters-the-battlefield (ETB) ability, DO NOT USE THIS TAG! Use etb. instead

resolvecost.
  - This is a special form of resolve which should be used in conjunction with cast.cost[] or resolve.cost[]
  - Specifies additional effects that trigger only on the condition that the cost was paid
  - triggers seperately from (and after) resolve tags, so both classes can be used.

etb.
  - use for cards with triggered "enters the battlefield" abilities
  - when a card with this tag enters the battlefield (from the stack, for example), a copy representing that card's ability automatically goes onto the stack.
  - An "ETB" counter will be placed on the card indicating that its enters-the-battlefield ability will resolve.
  - All cards with ETB abilities should have this class included.  If the card has an etb trigger but is not practical to script, keep the parameters empty.

etbcost.
  - specifies additional effects that trigger only on the condition that a cost was paid (in cast.cost[] or resolve.cost[])
  - functions similar to resolvecost.

destroy.
  - use for cards with abilities that trigger when they are sent to the graveyard
  - functions similar to etb. tags
  - If the card has destroy trigger but is too complicated to script, keep the parameters empty.

destroycost.
  - This class was designed exclusively for the persist mechanic, however it may be expanded for use as a general class if necessary.

exile.
  - use for cards with abilities that trigger when they are sent to the exiled zone
  - functions similar to etb. tags
  - If the card has an exile trigger but is too complicated to script, keep the parameters empty.

attack.
  - use for cards with abilities that trigger when they are declared as an attacker.
  - functions similar to etb. tags
  - If the card has an attack trigger but is too complicated to script, keep the parameters empty.

block.
  - use for cards with abilities that trigger when they are declared as a blocker.
  - functions similar to etb. tags
  - If the card has a block trigger but is too complicated to script, keep the parameters empty.

activatecost#.
  - Use for cards whose activated abilities require a non-mana cost to activate (For example, tapping the card or sacrificing it.)
  - Since a card may have multiple abilities (i.e. Planeswalkers), the number indicates which ability is being scripted (to be consistent, it should be based on the logical written order in the rules text).
  - If a card has exactly one ability, and that ability is scripted, then the player will not be prompted to enter an ability number.
  - If an ability is too difficult to be scripted, then put "activate#.[];" to allow the prompt window to appear.
  - When the ability is activated, the cost will be paid and then a copy of the card representing its ability will be placed on the stack.
  - If the cost cannot be paid (card is already tapped, not enough counters to remove), then the ability will not go on the stack and the player will be notified.
  - Due to the way the autoscripts work, only costs that affect its own card should be scripted, so don't do it for "sacrifice a creature"-type costs.

activate#.
  - use when a card has an activated (or triggered) ability that uses the stack.
  - The number should always be paired with its corresponding activatecost#. tag if one exists (not all activated abilities require a cost, however).
  - This tag is only used for resolving the ability from the stack. The card gets placed onto the stack through the "Activate Card Ability" cardaction.
  - This tag functions similarly to the resolve. tag, such that it includes the scripting that should be performed when the ability RESOLVES from the stack.
  - NOTE: if the player activates a card's ability and selects a number which is not scripted, the ability will go onto the stack but resolving will have no effect.
  


##################################################
#actions
##################################################

cost[type, quantity]
  - used for cards that require additional costs or special conditions to cast, such as X in mana costs, kicker, conspire, landfall, etc.
  - type is a phrase used to describe the cost in the player's prompt window, it has no scripting relevence unless it is x
  - If the quantity is 1, then the prompt window will be a yes/no prompt.  Otherwise, it will be an integer input window.
  - If the type is x (as in for {X} mana costs), it will put X counter(s) on the card.  For any other type, it will put Cost counters on it.
  - The counters placed on the card from cost[] tags are important to alert the other autoscript tags that the cost has been paid.  It is tied into all ___cost.[] classes.

marker[name, quantity];
  - "markers" are the technical OCTGN term for counters, and the two words are interchangable.
  - adds a specified quantity of named counters to the card
  - see "scripts/replacements.py" for the list of script-available counter names

token[name, quantity];
  - creates a specified number of named tokens onto the battlefield
  - see "scripts/replacements.py" for the list of script-available token names
  - NOTE: If a card produces or references a specific token but the method in which the token is created is not easily scriptable, then include this action outside
    of a class tag (i.e. "token[alasaproling, 1]") so that the Auto-Create Token scripts can recognize the token.

moveto[pile]
  - causes the card to be sent to the specified pile instead of where it would normally go.
  - The following parameters can be used:
    - hand
    - graveyard
    - exile
    - table (puts it into play, will trigger ETB classes)
    - stack (casts the card, will trigger CAST classes)
    - shuffle (shuffles card into library)
    - top (puts card on top of library)
    - bottom (puts card on bottom of library)
    - [any integer value] (moves card to specific position from top of library)

tapped[]
  - Will tap the selected card
  - no additional parameters necessary


untapped[]
  - Will untap the selected card
  - no additional parameters necessary

highlight[type]
  - will highlight the selected card if type is AttackColor, BlockColor, DoesNotUntapColor
  - can be used in conjunction with tapped to make a card attack.

transform[condition]
  - Exclusively for the Innistrad block TRANSFORM mechanic
  - shouldn't be used for non-Innistrad cards

cascade[]
  - Exclusively for the Alara Reborn CASCADE cards
  - shouldn't be used for non-Alara Reborn cards

##################################################
#quantifiers (quantity)
##################################################

These can be used by several actions in place of a number whenever "quantity" is required.

2x[quantity]
 - combine this with other quantifiers
 - doubles the quantity

-[quantity] (negative sign)
 - combine this with other quantifiers
 - returns a negative of quantity

x (lowercase)
 - returns the number of 'x' markers on the card (from .cost[] actions)

cost
 - returns the number of 'cost' markers on the card (from .cost[] actions)

ask
 - prompts a box which asks the user to input the number
 - returns the chosen number
 - should be used for any ability which counts a certain value of something in the game (power of a card, number of Lands in play), to give the player more control over the scripts.

##################################################
#NOTES
##################################################

The autoscript system was designed to automate the more tedious aspects of OCTGN gameplay, such as adding counters on a card and creating specific tokens, and to
provide a more realistic game experience (regarding the Stack). It is NOT designed for complete rules-enforcement.
Due to the nature of OCTGN's python scripting interacting with its components, there are several limitations as to what the Autoscripts can do.
  - I have made the decision to focus on abilities which modify the card that the ability originates from (Adding counters, tapping/untapping, changing highlight color)
    and token-generating abilities.
  - Abilities like drawing cards and changing life totals, or affecting other cards (such as through targeting) have been avoided since OCTGN cannot 100% predict the
    more complicated game states, and it ends up being a big mess.